// This is using IntelliJ's Dart grammar as base because I know nothing about grammars!

{
  psiImplUtilClass="com.wyrdtech.d.intellid.util.DPsiImplUtil"

  parserClass="com.wyrdtech.d.intellid.parser.DParser"
  parserUtilClass="com.wyrdtech.d.intellid.parser.DGeneratedParserUtilBase"

  implements="com.wyrdtech.d.intellid.psi.DPsiCompositeElement"
  extends="com.wyrdtech.d.intellid.psi.impl.DPsiCompositeElementImpl"

  psiClassPrefix="D"
  psiImplClassSuffix="Impl"
  psiPackage="com.wyrdtech.d.intellid.psi"
  psiImplPackage="com.wyrdtech.d.intellid.psi.impl"

  elementTypeHolderClass="com.wyrdtech.d.intellid.lexer.DTokenType"
  elementTypePrefix=""
  elementTypeClass="com.wyrdtech.d.intellid.lexer.DElementType"
  tokenTypeClass="com.wyrdtech.d.intellid.lexer.DElementType"

  tokenTypeClass="com.wyrdtech.d.intellid.lexer.DTokenTypes"

  generateFirstCheck=50

  tokens = [
    ABSTRACT="abstract"
    ALIAS="alias"
    ALIGN="align"
    ASM="asm"
    ASSERT="assert"
    AUTO="auto"
    BODY="body"
    BOOL="bool"
    BREAK="break"
    BYTE="byte"
    CASE="case"
    CAST="cast"
    CATCH="catch"
    CDOUBLE="cdouble"
    CENT="cent"
    CFLOAT="cfloat"
    CHAR="char"
    CLASS="class"
    CONST="const"
    CONTINUE="continue"
    CREAL="creal"
    DCHAR="dchar"
    DEBUG="debug"
    DEFAULT="default"
    DELEGATE="delegate"
    DELETE="delete" // this is deprecated
    DEPRECATED="deprecated"
    DO="do"
    DOUBLE="double"
    ELSE="else"
    ENUM="enum"
    EXPORT="export"
    EXTERN="extern"
    FALSE="false"
    FINAL="final"
    FINALLY="finally"
    FLOAT="float"
    FOR="for"
    FOREACH="foreach"
    FOREACH_REVERSE="foreach_reverse"
    FUNCTION="function"
    GOTO="goto"
    IDOUBLE="idouble"
    IF="if"
    IFLOAT="ifloat"
    IMMUTABLE="immutable"
    IMPORT="import"
    IN="in"
    INOUT="inout"
    INT="int"
    INTERFACE="interface"
    INVARIANT="invariant"
    IREAL="ireal"
    IS="is"
    LAZY="lazy"
    LONG="long"
    MACRO="macro"
    MIXIN="mixin"
    MODULE="module"
    NEW="new"
    NOTHROW="nothrow"
    NULL="null"
    OUT="out"
    OVERRIDE="override"
    PACKAGE="package"
    PRAGMA="pragma"
    PRIVATE="private"
    PROTECTED="protected"
    PUBLIC="public"
    PURE="pure"
    REAL="real"
    REF="ref"
    RETURN="return"
    SCOPE="scope"
    SHARED="shared"
    SHORT="short"
    STATIC="static"
    STRUCT="struct"
    SUPER="super"
    SWITCH="switch"
    SYNCHRONIZED="synchronized"
    TEMPLATE="template"
    THIS="this"
    THROW="throw"
    TRUE="true"
    TRY="try"
    TYPEDEF="typedef" // deprecated
    TYPEID="typeid"
    TYPEOF="typeof"
    UBYTE="ubyte"
    UCENT="ucent"
    UINT="uint"
    ULONG="ulong"
    UNION="union"
    UNITTEST="unittest"
    USHORT="ushort"
    VERSION="version"
    VOID="void"
    VOLATILE="volatile" // deprecated
    WCHAR="wchar"
    WHILE="while"
    WITH="with"
    FILE="__FILE__"
    MODULE="__MODULE__"
    LINE="__LINE__"
    FUNCTION__="__FUNCTION__"
    PRETTY_FUNCTION__="__PRETTY_FUNCTION__"
    GSHARED="__gshared"
    TRAITS="__traits"
    VECTOR="__vector"
    PARAMETERS="__parameters"

  LBRACE="{"
  RBRACE="}"
  LBRACKET="["
  RBRACKET="]"
  LPAREN="("
  RPAREN=")"
  SEMICOLON=";"
  MINUS="-"
  MINUS_EQ="-="
  MINUS_MINUS="--"
  PLUS="+"
  PLUS_PLUS="++"
  PLUS_EQ="+="
  DIV="/"
  DIV_EQ="/="
  MUL="*"
  MUL_EQ="*="
  INT_DIV="~/"
  INT_DIV_EQ="~/="
  REM_EQ="%="
  REM="%"
  BIN_NOT="~"
  NOT="!"
  
  EXPRESSION_BODY_DEF="=>"
  EQ="="
  EQ_EQ="=="
  NEQ="!="
  DOT="."
  COMMA=","
  COLON=":"
  GT=">"
  GT_EQ=">="
  GT_GT_EQ=">>="
  LT="<"
  LT_EQ="<="
  LT_LT="<<"
  LT_LT_EQ="<<="
  QUEST="?"
  OR="|"
  OR_EQ="|="
  OR_OR="||"
  XOR="^"
  XOR_EQ="^="
  AND="&"
  AND_EQ="&="
  AND_AND="&&"
  HASH="#"
  AT="@"
  // TODO: There are definitely some missing (asm shifts, etc.). See: http://dlang.org/lex.html#Identifier
  ]

  extends(".*Expression")="expression"
}


DUnit ::= topLevelDefinition*
private topLevelDefinition ::= importStatement
                             | partStatement
                             | classDefinition
                             | functionTypeAlias
                             | getterOrSetterDeclaration
                             | functionDeclarationWithBodyOrNative
                             | varDeclarationListWithSemicolon
                             | incompleteDeclaration // not valid according to spec, but we'd like it to be parsed in order to have completion
                             {recoverWhile="top_level_recover"}
private top_level_recover ::= !(<<nonStrictID>> | '@' | 'abstract' | 'class' | 'const' | 'export' | 'external' | 'final' | 'get' | 'import' | 'library' | 'part' | 'set' | 'static' | 'typedef' | 'var' | 'void')

incompleteDeclaration ::= metadata* ('external' | 'static' | 'final' | 'const')* type | metadata+;

importStatement ::= metadata* 'import' pathOrLibraryReference combinator* ';' {
  pin=3
  implements="com.wyrdtech.d.intellid.psi.DImportOrExportStatement"
  methods = [
    getUri
    libraryExpression = "pathOrLibraryReference"
    importPrefix = "componentName"
  ]
}

private combinator ::= showCombinator | hideCombinator

showCombinator ::= 'show' libraryReferenceList
hideCombinator ::= 'hide' libraryReferenceList
libraryReferenceList ::= libraryComponentReferenceExpression (',' libraryComponentReferenceExpression)*

partStatement ::= metadata* 'part' pathOrLibraryReference ';' {
  pin=3
  methods = [ getPath ]
}

metadata ::= '@' simpleQualifiedReferenceExpression arguments?

pathOrLibraryReference ::= stringLiteralExpression
{mixin="com.wyrdtech.d.intellid.psi.impl.DFileReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

libraryId ::= <<nonStrictID>> ('.' <<nonStrictID>>)*
{mixin="com.wyrdtech.d.intellid.psi.impl.DLibraryReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"
recoverWhile="semicolon_recover"}

private semicolon_recover ::= !(';')

varAccessDeclaration ::= metadata* 'static'? (finalOrConst type componentName | finalOrConst componentName | type componentName | 'var' componentName)
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private finalOrConst ::= 'final' | 'const'
private varDeclarationListWithSemicolon ::= varDeclarationList ';'{pin=1}
varDeclarationList ::= varAccessDeclaration varInit? (',' varDeclarationListPart)* {pin = 3}
varDeclarationListPart ::= componentName varInit?
{
  mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl"
  implements="com.wyrdtech.d.intellid.psi.DComponent"
  methods= [getMetadataList]
}

operatorDeclaration ::= operatorDeclarationWithReturnType | operatorDeclarationWithoutReturnType // 'operator' is a valid identifier, so can be a returnType
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDOperator" implements="com.wyrdtech.d.intellid.psi.DOperator"}
private operatorDeclarationWithReturnType    ::= metadata* 'external'? returnType 'operator' userDefinableOperator formalParameterList (';' | functionBodyOrNative) {pin=5}
private operatorDeclarationWithoutReturnType ::= metadata* 'external'?            'operator' userDefinableOperator formalParameterList (';' | functionBodyOrNative) {pin=4}

classDefinition ::= metadata* 'abstract'? 'class' componentName typeParameters? (mixinApplication | standardClassDeclarationTail)
{pin=4 mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDPsiClass" implements="com.wyrdtech.d.intellid.psi.DClass"}

mixinApplication ::= '=' type mixins? interfaces? ';' {pin = 1}
private standardClassDeclarationTail ::= (superclass mixins?)? interfaces? ('native' stringLiteralExpression?)? classBody?

classBody ::= '{' classMembers '}' {pin=1}
classMembers ::= classMemberDefinition*
{recoverWhile="simple_scope_recover" implements="com.wyrdtech.d.intellid.psi.DExecutionScope"}
private simple_scope_recover ::= !'}'

private getterOrSetterDeclaration ::= getterDeclaration | setterDeclaration

getterDeclaration ::= getterDeclarationWithReturnType | getterDeclarationWithoutReturnType // 'get' is a valid identifier, so can be a returnType
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private getterDeclarationWithReturnType    ::= metadata* ('external' | 'static')* returnType 'get' componentName formalParameterList? (';' | functionBodyOrNative) {pin=5}
private getterDeclarationWithoutReturnType ::= metadata* ('external' | 'static')*            'get' componentName formalParameterList? (';' | functionBodyOrNative) {pin=4}

setterDeclaration ::= setterDeclarationWithReturnType | setterDeclarationWithoutReturnType // 'set' is a valid identifier, so can be a returnType
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private setterDeclarationWithReturnType    ::= metadata* ('external' | 'static')* returnType 'set' componentName formalParameterList (';' | functionBodyOrNative) {pin=5}
private setterDeclarationWithoutReturnType ::= metadata* ('external' | 'static')*            'set' componentName formalParameterList (';' | functionBodyOrNative) {pin=4}

typeParameters ::= '<' typeParameter (',' typeParameter)* '>' {pin=1}
typeParameter ::= metadata* componentName ('extends' type)?
{recoverWhile="type_parameter_recover" mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}

private type_parameter_recover ::= !(<<nonStrictID>> | '(' | ',' | '=' | '>' | '@' | 'abstract' | 'class' | 'const' | 'export' | 'extends' |
                                     'external' | 'final' | 'get' | 'implements' | 'import' | 'library' | 'native' | 'part' | 'set' |
                                     'static' | 'typedef' | 'var' | 'void' | '{')
superclass ::= 'extends' type {pin=1}
mixins ::= 'with' typeList {pin=1}
interfaces ::= 'implements' typeList {pin=1}

private classMemberDefinition ::= factoryConstructorDeclaration
                                | namedConstructorDeclaration
                                | operatorDeclaration
                                | getterOrSetterDeclaration
                                | methodDeclaration
                                | varDeclarationListWithSemicolon
                                | incompleteDeclaration // not valid according to spec, but we'd like it to be parsed in order to have completion
                                {recoverWhile="class_member_recover"}
private class_member_recover ::= !(<<nonStrictID>> | '@' | 'abstract' | 'class' | 'const' | 'export' | 'external' | 'factory' | 'final' | 'get' | 'import' | 'library' | 'operator' | 'part' | 'set' | 'static' | 'typedef' | 'var' | 'void' | '}' )

private functionBodyOrNative ::= 'native' functionBody
                               | functionNative
                               | functionBody

private functionNative ::= 'native' (stringLiteralExpression ';' | ';' | stringLiteralExpression functionBody)

methodDeclaration ::= metadata* ('external' | 'static' | 'const')* functionDeclarationPrivate initializers? (';' | functionBodyOrNative | redirection)?
{pin=3 mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
namedConstructorDeclaration ::= metadata* ('external' | 'const')* referenceExpression '.' componentName formalParameterList initializers? (';' | functionBodyOrNative | redirection)?
{pin=6 mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}

initializers ::= ':' superCallOrFieldInitializer (',' superCallOrFieldInitializer)*

redirection ::= ':' 'this' ('.' referenceExpression)? arguments  {pin=2}

fieldInitializer ::= ('this' '.')? referenceExpression '=' expression {pin=2}

superCallOrFieldInitializer ::= ('super' | 'this') ('.' referenceExpression)? arguments
                              | fieldInitializer
                              {recoverWhile="super_call_or_field_initializer_recover"}
private super_call_or_field_initializer_recover ::= !(<<nonStrictID>> | ',' | ':' | ';' | '=>' | '@' | 'abstract' | 'class' | 'const' |
                                                      'export' | 'external' | 'factory' | 'final' | 'get' | 'import' | 'library' |
                                                      'native' | 'operator' | 'part' | 'set' | 'static' | 'typedef' | 'var' | 'void' | '{' |
                                                      '}' )

functionTypeAlias ::= metadata* 'typedef' functionPrefix typeParameters? formalParameterList ';'
{pin=5 mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private functionPrefix ::= returnType componentName | componentName

factoryConstructorDeclaration ::= metadata* ('external' | 'const')* 'factory' referenceExpression ('.' componentName)? formalParameterList factoryTail?
{pin=3 mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private factoryTail ::= varFactoryDeclaration ';' | functionBodyOrNative | ';' {pin(".*")=1}
private varFactoryDeclaration ::= '=' type ['.' referenceExpression] {pin(".*")=1}

userDefinableOperator ::= binaryOperator |
                          '~' |
                          '[' ']' '='?
private binaryOperator ::= multiplicativeOperator |
                           additiveOperator |
                           shiftOperator|
                           relationalOperator|
                           '==' |
                           bitwiseOperator

multiplicativeOperator ::= '*' | '/' | '%' | '~/'
additiveOperator ::= '+' | '-'
shiftOperator ::= '<<' | shiftRightOperator
relationalOperator ::= '>=' | '>' | '<=' | '<'
bitwiseOperator ::= '&' | '^' | '|'
shiftRightOperator ::= '>' '>'

assignmentOperator ::= '=' | '*=' | '/=' | '~/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='
equalityOperator ::= '==' | '!='

formalParameterList ::= '(' normalFormalParameter (',' normalFormalParameter)* (',' namedFormalParameters)? ')'
                      | '(' namedFormalParameters? ')'

fieldFormalParameter ::= metadata* finalConstVarOrType? 'this' '.' referenceExpression formalParameterList?

namedFormalParameters ::= '[' defaultFormalNamedParameter (',' defaultFormalNamedParameter)* ']' |
                          '{' defaultFormalNamedParameter (',' defaultFormalNamedParameter)* '}'

defaultFormalNamedParameter ::= normalFormalParameter (('=' | ':') expression)? {recoverWhile="default_formal_parameter_recover"}
private default_formal_parameter_recover ::= !(')' | ',' | ']' | '}')

normalFormalParameter ::= functionSignature
                        | fieldFormalParameter
                        | simpleFormalParameter {
  methods = [findComponentName]
}

simpleFormalParameter ::= declaredIdentifier | metadata* componentName
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private declaredIdentifier ::= metadata* finalConstVarOrTypeAndComponentName;

returnType ::= 'void' | type

private finalConstVarOrType ::= 'final' type? | 'const' type? | 'var' | type // Be careful on using it! It may erroneously consume 'type?'. See finalConstVarOrTypeAndComponentName
private finalConstVarOrTypeAndComponentName ::= 'final' type componentName |
                                                'final'      componentName |
                                                'const' type componentName |
                                                'const'      componentName |
                                                'var'        componentName |
                                                        type componentName

qualifiedComponentName ::= << nonStrictID >> ('.' << nonStrictID >>)*
{mixin="com.wyrdtech.d.intellid.psi.impl.DQNamedElementImpl" implements="com.wyrdtech.d.intellid.psi.DQNamedElement"}

componentName ::= << nonStrictID >>
{mixin="com.wyrdtech.d.intellid.psi.impl.DNamedElementImpl" implements="com.wyrdtech.d.intellid.psi.DNamedElement"}

// see nonStrictID
id ::= IDENTIFIER

type ::= simpleQualifiedReferenceExpression typeArguments? {
  pin=1
  methods=[
    resolveReference
  ]
}

typeArguments ::= '<' typeList '>'
typeList ::= type (',' type)*

block ::= '{' statements '}' {pin=1}

statements ::= statement* {implements="com.wyrdtech.d.intellid.psi.DExecutionScope"}
private statement ::= label* nonLabelledStatement {pin=2 recoverWhile="statement_recover"}
private statement_recover ::= !(<<nonStrictID>> | <<parenthesizedExpressionWrapper>> | <<varInitWrapper>> | '!' | '!=' | '%' | '%=' | '&&' |
                                '&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' | '/=' | ':' |
                                 ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '=>' | '>' | '>=' | '>>=' | '?' | '@' | '[' | ']' | '^' |
                                 '^=' | 'abstract' | 'as' | 'assert' | 'break' | 'case' | 'catch' | 'class' | 'const' | 'continue' |
                                 'default' | 'deferred' | 'do' | 'else' | 'export' | 'external' | 'factory' | 'final' | 'finally' | 'for' | 'get' |
                                 'hide' | 'if' | 'import' | 'is' | 'library' | 'native' | 'new' | 'on' | 'operator' | 'part' | 'rethrow' |
                                 'return' | 'set' | 'show' | 'static' | 'super' | 'switch' | 'this' | 'throw' | 'try' | 'typedef' | 'var' |
                                 'void' | 'while' | '{' | '|' | '|=' | '||' | '}' | '~' | '~/' | '~/=' | CLOSING_QUOTE | FALSE | HASH |
                                 HEX_NUMBER | LONG_TEMPLATE_ENTRY_END | LONG_TEMPLATE_ENTRY_START | NULL | NUMBER | OPEN_QUOTE |
                                 RAW_SINGLE_QUOTED_STRING | RAW_TRIPLE_QUOTED_STRING | REGULAR_STRING_PART | SHORT_TEMPLATE_ENTRY_START |
                                 TRUE)

private nonLabelledStatement ::= block // Guard to break tie with map literal.  todo why ';'?
                               | functionDeclarationWithBody ';'?
                               | forStatement ';'?
                               | whileStatement ';'?
                               | doWhileStatement ';'?
                               | switchStatement ';'?
                               | ifStatement ';'?
                               | rethrowStatement
                               | tryStatement
                               | breakStatement
                               | continueStatement
                               | returnStatement
                               | throwStatementWithSemicolon
                               | assertStatement
                               | statementFollowedBySemiColon
                               | ';'
private statementFollowedBySemiColon ::= (varDeclarationList | expression) ';' {pin=1}

label::= componentName ':'
{
  mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl"
  implements="com.wyrdtech.d.intellid.psi.DComponent"
  methods = [getMetadataList]
}

private expressionWithRecoverUntilParen ::= expression {recoverWhile="not_paren_recover"}
private not_paren_recover ::= !')'

whileStatement ::= 'while' '(' expressionWithRecoverUntilParen ')' statement {pin=1}
doWhileStatement ::= 'do' statement 'while' '(' expressionWithRecoverUntilParen ')' ';' {pin=1}
forStatement ::= 'for' forLoopPartsInBraces statement {pin=1}
//todo component
assertStatement ::= 'assert' '(' expressionWithRecoverUntilParen ')' ';' {pin=1}
breakStatement ::= 'break' referenceExpression? ';' {pin=1}
continueStatement ::= 'continue' referenceExpression? ';' {pin=1}
returnStatement ::= 'return' expression? ';' {pin=1}
rethrowStatement ::= 'rethrow' ';' {pin=1}
private throwStatementWithSemicolon ::= throwStatement ';' {pin=1}
throwStatement ::= 'throw' expression? {pin=1} // in D spec this is 'throw expression', not 'throw statement'

forLoopPartsInBraces::= '(' forLoopParts ')'
forLoopParts::= varDeclarationList ';' expression? ';' expressionList?
              | forInPart
              | expressionList? ';' expression? ';' expressionList?
              {recoverWhile="for_loops_parts_recover"}

forInPart ::= (varAccessDeclaration | componentName) 'in' expression

private for_loops_parts_recover ::= !')'

ifStatement ::= 'if' '(' expressionWithRecoverUntilParen ')' statement ('else' statement)?  {pin=1}
switchStatement ::= 'switch' '(' expressionWithRecoverUntilParen ')' '{' switchCase* defaultCase? '}' {pin=1}

switchCase ::= label? ('case' expression ':')+ statements {recoverWhile="switch_case_recover"}
private switch_case_recover ::= !('case' | 'default' | '}' | <<nonStrictID>>)
defaultCase::= label? ('case' expression ':')* 'default' ':' statements

tryStatement ::= 'try' block (onPart+ finallyPart? | finallyPart) {pin=1}
onPart ::= catchPart block | 'on' type catchPart? block {pin=1}
catchPart ::= 'catch' '(' componentName (',' componentName)? ')' {pin=1}
finallyPart::= 'finally' block {pin=1}

varInit ::= '=' expression {pin=1}

expressionList ::= expression (',' expression)*
arguments ::= '(' argumentList? ')'

argumentList ::= argumentListPart (',' argumentListPart)* {recoverWhile="argument_list_recover"}
private argument_list_recover ::= !(')')
private argumentListPart ::= namedArgument | expression {recoverWhile="argument_list_part_recover"}
private argument_list_part_recover ::= !(')' | ',')

namedArgument ::= parameterNameReferenceExpression ':' expression {
  methods = [
    getParameterReferenceExpression
    getExpression
  ]
}

parameterNameReferenceExpression ::= << nonStrictID >>
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

expression ::= assignExpressionWrapper {recoverWhile="expression_recover"}
private expression_recover ::= !(<<nonStrictID>> | <<parenthesizedExpressionWrapper>> | '!' | '!=' | '%' | '%=' |
                                 '&&' | '&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                 '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '=>' | '>' | '>=' | '>>=' | '?' | '@' | '[' |
                                 ']' | '^' | '^=' | 'abstract' | 'as' | 'assert' | 'break' | 'case' | 'catch' | 'class' | 'const' |
                                 'continue' | 'default' | 'deferred' | 'do' | 'else' | 'export' | 'external' | 'factory' | 'final' | 'finally' | 'for' |
                                 'get' | 'hide' | 'if' | 'import' | 'is' | 'library' | 'native' | 'new' | 'on' | 'operator' | 'part' |
                                 'rethrow' | 'return' | 'set' | 'show' | 'static' | 'super' | 'switch' | 'this' | 'throw' | 'try' |
                                 'typedef' | 'var' | 'void' | 'while' | '{' | '|' | '|=' | '||' | '}' | '~' | '~/' | '~/=' | CLOSING_QUOTE |
                                  FALSE | HASH | HEX_NUMBER | LONG_TEMPLATE_ENTRY_END | LONG_TEMPLATE_ENTRY_START | NULL | NUMBER |
                                  OPEN_QUOTE | RAW_SINGLE_QUOTED_STRING | RAW_TRIPLE_QUOTED_STRING | REGULAR_STRING_PART |
                                  SHORT_TEMPLATE_ENTRY_START | TRUE)

private assignExpressionWrapper ::= ternaryExpressionWrapper assignExpression*
left assignExpression ::= assignmentOperator ternaryExpressionWrapper {pin=1} // todo right associate

private ternaryExpressionWrapper ::= logicOrExpressionWrapper ternaryExpression?
left ternaryExpression ::= '?' expression ':' ternaryExpressionWrapper

private logicOrExpressionWrapper ::= logicAndExpressionWrapper logicOrExpression*
left logicOrExpression ::= '||' logicAndExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private logicAndExpressionWrapper ::= compareExpressionWrapper logicAndExpression*
left logicAndExpression ::= '&&' compareExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private compareExpressionWrapper ::= bitwiseExpressionWrapper compareExpression*
left compareExpression ::= (relationalOperator | equalityOperator) bitwiseExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private bitwiseExpressionWrapper ::= shiftExpressionWrapper bitwiseExpression*
left bitwiseExpression ::= bitwiseOperator shiftExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private shiftExpressionWrapper ::= additiveExpressionWrapper shiftExpression*
left shiftExpression ::= shiftOperator additiveExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private additiveExpressionWrapper ::= multiplicativeExpressionWrapper additiveExpression*
left additiveExpression ::= additiveOperator multiplicativeExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private multiplicativeExpressionWrapper ::= prefixExpression multiplicativeExpression*
left multiplicativeExpression ::= multiplicativeOperator prefixExpression
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

prefixExpression ::= (prefixOperator prefixExpression) | suffixExpressionWrapper
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
prefixOperator ::= '-' | '+' | '--' | '++' | '!' | '~' | '?'

private suffixExpressionWrapper ::= valueExpression suffixExpression*
left suffixExpression ::= ('--' | '++')
{mixin="com.wyrdtech.d.intellid.psi.impl.DOperatorExpressionImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

valueExpression ::= primary callOrArrayAccessOrQualifiedRefExpression cascadeReferenceExpression* (isExpression | asExpression)?
left isExpression ::= 'is' '!'? type
left asExpression ::= 'as' type
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private primary ::=  literalExpression |
                     functionExpression |
                     newExpression |
                     constConstructorExpression |
                     refOrThisOrSuperOrParenExpression

parenthesizedExpression ::= '(' expressionInParentheses ')'
{pin=1 mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
private expressionInParentheses ::= expression | statement {recoverWhile=parenthesesRecovery}
private parenthesesRecovery ::= !')'

private callOrArrayAccessOrQualifiedRefExpression ::= (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*

private refOrThisOrSuperOrParenExpression ::= (referenceExpression | thisExpression | superExpression | << parenthesizedExpressionWrapper >>)

left callExpression ::= arguments
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
left arrayAccessExpression ::= arrayAccess
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private arrayAccess ::= '[' expression? ']' {pin=1}

libraryComponentReferenceExpression ::= << nonStrictID >>
{mixin="com.wyrdtech.d.intellid.psi.impl.DLibraryComponentReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

referenceExpression ::= << nonStrictID >>
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

left qualifiedReferenceExpression ::= '.' referenceExpression {elementType="referenceExpression"}
left cascadeReferenceExpression ::= '.''.' << cascadeStopper >> (arrayAccess | refOrThisOrSuperOrParenExpression callOrArrayAccessOrQualifiedRefExpression) << varInitWrapper >>
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

simpleQualifiedReferenceExpression ::= referenceExpression qualifiedReferenceExpression* {elementType="referenceExpression"}

thisExpression ::= 'this'
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
superExpression ::= 'super'
{mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

newExpression ::= 'new' type ('.' referenceExpression)? arguments
{pin=1 mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
constConstructorExpression ::= 'const' type ('.' referenceExpression)? arguments
{pin=1 mixin="com.wyrdtech.d.intellid.psi.impl.DReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

literalExpression ::= NULL | TRUE | FALSE | NUMBER | HEX_NUMBER | stringLiteralExpression | symbolLiteralExpression | mapLiteralExpression | listLiteralExpression
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

symbolLiteralExpression ::= HASH (userDefinableOperator | simpleQualifiedReferenceExpression) {pin=1}

stringLiteralExpression ::= (RAW_SINGLE_QUOTED_STRING | RAW_TRIPLE_QUOTED_STRING | stringTemplate)+
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

private stringTemplate ::= OPEN_QUOTE (REGULAR_STRING_PART | shortTemplateEntry | longTemplateEntry)* CLOSING_QUOTE {pin=1}
shortTemplateEntry ::= SHORT_TEMPLATE_ENTRY_START (thisExpression | referenceExpression) {pin=1}
longTemplateEntry ::= LONG_TEMPLATE_ENTRY_START expression LONG_TEMPLATE_ENTRY_END {pin=1}

listLiteralExpression ::= 'const'? typeArguments? '[' (expressionList ','?)? ']'
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}
mapLiteralExpression ::= 'const'? typeArguments? '{' (mapLiteralEntry (',' mapLiteralEntry)* ','? )? '}'
{mixin="com.wyrdtech.d.intellid.psi.impl.DClassReferenceImpl" implements="com.wyrdtech.d.intellid.psi.DReference"}

mapLiteralEntry ::= expression ':' expression {recoverWhile="map_literal_entry_recover"}
private map_literal_entry_recover ::= !(',' | '}')

functionExpression ::= formalParameterList functionExpressionBody
functionSignature ::= metadata* functionDeclarationPrivate
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
private functionDeclarationPrivate ::= returnType componentName formalParameterList | componentName formalParameterList // todo remove, use functionSignature as in spec
functionDeclarationWithBodyOrNative ::= metadata* 'external'? (returnType componentName formalParameterList | componentName formalParameterList) ( ';' | functionBodyOrNative)
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}
functionDeclarationWithBody ::= metadata*  (returnType componentName formalParameterList | componentName formalParameterList) functionBody // todo merge with functionDeclarationWithBodyOrNative
{mixin="com.wyrdtech.d.intellid.psi.impl.AbstractDComponentImpl" implements="com.wyrdtech.d.intellid.psi.DComponent"}

functionBody ::= arrowBodyWithSemi | block
private arrowBodyWithSemi ::= arrowBody ';' {pin=1}

functionExpressionBody ::= arrowBody | block
private arrowBody ::= '=>' (expression | throwStatement) {pin=1}
